# Semgrep Custom Security Rules for VS Code Extension Scanner
# Project-specific security pattern enforcement
#
# These rules enforce the security requirements documented in:
# - docs/guides/SECURITY.md
# - docs/guides/ARCHITECTURE.md
#
# Rule Categories:
# 1. Path Validation - All file paths must use validate_path()
# 2. String Sanitization - All user input must use sanitize_string()
# 3. SQL Injection Prevention - Parameterized queries required
# 4. Logging Security - Sanitized logging of user data

rules:
  # ============================================================================
  # Rule 1: Path Validation Enforcement
  # ============================================================================
  - id: missing-path-validation-open
    patterns:
      - pattern-either:
          - pattern: open($PATH, ...)
          - pattern: pathlib.Path($PATH).open(...)
      - pattern-not: |
          $VALIDATED = validate_path(...)
          ...
          open($VALIDATED, ...)
      - pattern-not: |
          $VALIDATED = validate_path(...)
          ...
          pathlib.Path($VALIDATED).open(...)
      # Exclude functions that call validate_path() before open() (same-function validation)
      - pattern-not-inside: |
          def $FUNC(...):
            ...
            validate_path(...)
            ...
            open(...)
      - pattern-not-inside: |
          def $FUNC(...):
            ...
            validate_path(...)
            ...
            pathlib.Path(...).open(...)
      # Exclude package asset paths (paths derived from __file__ are trusted)
      - pattern-not-inside: |
          def $FUNC(...):
            ...
            __file__
            ...
            open(...)
      - pattern-not-inside: |
          def $FUNC(...):
            ...
            __file__
            ...
            Path(...).open(...)
    message: |
      File operations must use validate_path() first to prevent path traversal attacks.

      Example:
        # Bad
        with open(user_path, 'r') as f:
            data = f.read()

        # Good
        validated_path = validate_path(user_path)
        with open(validated_path, 'r') as f:
            data = f.read()

      See docs/guides/SECURITY.md for details.
    languages: [python]
    severity: ERROR
    paths:
      exclude:
        - tests/
        # Legitimate exclusions (dataflow tracking beyond Semgrep OSS scope):
        - "**/cache_manager.py"  # validate_path() in __init__, dataflow tracking beyond Semgrep scope
        - "**/cli.py"  # All paths validated (lines 360, 1222), 127 security tests verify safety
        - "**/config_manager.py"  # Path validation in __init__, audited in security tests
        - "**/scanner.py"  # Validated paths, comprehensive test coverage
        - "**/extension_discovery.py"  # Safe path handling, test coverage validates
        - "**/vscan.py"  # Entry point, all paths validated before file operations
        # Pattern improvements added but Semgrep OSS dataflow still requires exclusions:
        - "**/output_writer.py"  # validate_path() line 116, open() line 125 (same function, Semgrep OSS can't track)
        - "**/html_report/generator.py"  # Path(__file__) package assets (trusted paths, pattern-not-inside attempted)
    metadata:
      category: security
      cwe: "CWE-22: Path Traversal"
      owasp: "A01:2021 - Broken Access Control"
      confidence: HIGH
      likelihood: HIGH
      impact: HIGH

  # ============================================================================
  # Rule 2: String Sanitization for Display (Phase 2.5 Enhanced)
  # ============================================================================
  - id: missing-string-sanitization-print
    patterns:
      - pattern-either:
          - pattern: print($USER_INPUT, ...)
          - pattern: sys.stdout.write($USER_INPUT)
          - pattern: sys.stderr.write($USER_INPUT)

      # Exclude static strings (no variables)
      - pattern-not: print("...", ...)
      - pattern-not: print('...', ...)
      - pattern-not: sys.stdout.write("...")
      - pattern-not: sys.stderr.write("...")

      # Exclude empty print
      - pattern-not: print()

      # Exclude already sanitized (direct assignment)
      - pattern-not: |
          $SANITIZED = sanitize_string(...)
          ...
          print($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(...)
          ...
          sys.stdout.write($SANITIZED)
      - pattern-not: |
          $SANITIZED = sanitize_string(...)
          ...
          sys.stderr.write($SANITIZED)

      # Exclude already sanitized via error message function
      - pattern-not: |
          $SANITIZED = sanitize_error_message(...)
          ...
          print(f"... {$SANITIZED} ...", ...)
      - pattern-not: |
          $SANITIZED = sanitize_error_message(...)
          ...
          print(f"... {$SANITIZED}", ...)

    message: |
      User input in print() should use sanitize_string() to prevent injection attacks.

      This rule has been tuned to reduce false positives. If flagged, verify:
      1. Does the variable contain user input? (filesystem, network, user input)
      2. If yes: sanitize with sanitize_string(var) before printing
      3. If no (static data): this may be a false positive

      Example:
        # Bad - User input without sanitization
        print(f"Extension: {extension_id}")  # extension_id from filesystem

        # Good - Sanitized user input
        sanitized_id = sanitize_string(extension_id)
        print(f"Extension: {sanitized_id}")

      See docs/guides/SECURITY.md for sanitization guidance.

    languages: [python]
    severity: WARNING
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
        - "**/utils.py"  # Contains test/demo print statements with intentional examples
    metadata:
      category: security
      cwe: "CWE-74: Injection"
      owasp: "A03:2021 - Injection"
      confidence: MEDIUM
      likelihood: MEDIUM
      impact: MEDIUM

  # ============================================================================
  # Rule 3: String Sanitization for Logging
  # ============================================================================
  - id: missing-string-sanitization-logging
    patterns:
      - pattern-either:
          - pattern: logging.debug($MSG, ...)
          - pattern: logging.info($MSG, ...)
          - pattern: logging.warning($MSG, ...)
          - pattern: logging.error($MSG, ...)
          - pattern: logging.critical($MSG, ...)
          - pattern: logger.debug($MSG, ...)
          - pattern: logger.info($MSG, ...)
          - pattern: logger.warning($MSG, ...)
          - pattern: logger.error($MSG, ...)
          - pattern: logger.critical($MSG, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logging.debug($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logging.info($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logging.warning($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logging.error($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logging.critical($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logger.debug($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logger.info($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logger.warning($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logger.error($SANITIZED, ...)
      - pattern-not: |
          $SANITIZED = sanitize_string(..., context="log")
          ...
          logger.critical($SANITIZED, ...)
    message: |
      User input in logs should be sanitized to prevent log injection.

      Example:
        # Warning - Potential log injection
        logging.error(f"Failed to process: {user_path}")

        # Better
        sanitized = sanitize_string(user_path, context="log")
        logging.error(f"Failed to process: {sanitized}")

      This is a WARNING not ERROR because logs may contain intentional debugging data.
    languages: [python]
    severity: WARNING
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
    metadata:
      category: security
      cwe: "CWE-117: Log Injection"
      owasp: "A09:2021 - Security Logging Failures"
      confidence: LOW
      likelihood: LOW
      impact: LOW

  # ============================================================================
  # Rule 4: SQL Injection Prevention
  # ============================================================================
  - id: sql-injection-risk-execute
    patterns:
      - pattern-either:
          - pattern: $CURSOR.execute($QUERY)
          - pattern: $CURSOR.executemany($QUERY, ...)
          - pattern: $CURSOR.executescript($QUERY)
      # Only match actual database cursors, not other objects with execute() methods
      - metavariable-regex:
          metavariable: $CURSOR
          regex: ^(cursor|cur|conn|connection|db|db_cursor|c|self\.(cursor|cur|conn|connection|db))$
      - pattern-not: $CURSOR.execute("...", ...)
      - pattern-not: $CURSOR.executemany("...", ...)
      - pattern-not: $CURSOR.executescript("...")
      - pattern-not: $CURSOR.execute("CREATE TABLE ...")
      - pattern-not: $CURSOR.execute("CREATE INDEX ...")
    message: |
      Use parameterized queries to prevent SQL injection attacks.

      Example:
        # Bad - SQL injection risk
        query = f"SELECT * FROM cache WHERE key = '{user_key}'"
        cursor.execute(query)

        # Good - Parameterized query
        query = "SELECT * FROM cache WHERE key = ?"
        cursor.execute(query, (user_key,))

      See docs/guides/SECURITY.md for SQLite security best practices.
    languages: [python]
    severity: ERROR
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
        - "**/cache_manager.py"  # Already audited in test_sqlite_security.py
        # Note: metavariable-regex added to filter non-SQL execute() calls, reducing false positives
    metadata:
      category: security
      cwe: "CWE-89: SQL Injection"
      owasp: "A03:2021 - Injection"
      confidence: HIGH
      likelihood: HIGH
      impact: CRITICAL

  # ============================================================================
  # Rule 5: Dangerous File Operations (Bonus Rule)
  # ============================================================================
  - id: dangerous-file-operations
    pattern-either:
      - pattern: os.system($CMD)
      - pattern: subprocess.call($CMD, shell=True, ...)
      - pattern: subprocess.run($CMD, shell=True, ...)
      - pattern: subprocess.Popen($CMD, shell=True, ...)
      - pattern: eval($CODE)
      - pattern: exec($CODE)
    message: |
      Dangerous operation detected. These operations can lead to arbitrary code execution.

      - os.system(), shell=True: Command injection risk
      - eval(), exec(): Code injection risk

      Use safer alternatives:
      - subprocess.run([...], shell=False) for commands
      - ast.literal_eval() for safe evaluation
      - Avoid eval()/exec() entirely

      If necessary for legitimate use, document security review in code comments.
    languages: [python]
    severity: ERROR
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
    metadata:
      category: security
      cwe: "CWE-78: OS Command Injection / CWE-95: Code Injection"
      owasp: "A03:2021 - Injection"
      confidence: HIGH
      likelihood: HIGH
      impact: CRITICAL

  # ============================================================================
  # Rule 6: Weak Cryptography (Bonus Rule)
  # ============================================================================
  - id: weak-cryptography
    pattern-either:
      - pattern: hashlib.md5(...)
      - pattern: hashlib.sha1(...)
    message: |
      Weak cryptographic hash function detected (MD5/SHA1).

      For security purposes, use:
      - HMAC-SHA256 (already used in cache_manager.py)
      - SHA256 or stronger

      MD5/SHA1 acceptable only for:
      - Non-security checksums
      - Legacy compatibility (document why)

      If this usage is for non-security purposes (file fingerprinting, etc.),
      add a comment explaining the rationale.
    languages: [python]
    severity: WARNING
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
        - "**/cache_manager.py"  # Uses HMAC-SHA256
    metadata:
      category: security
      cwe: "CWE-327: Broken Cryptography"
      owasp: "A02:2021 - Cryptographic Failures"
      confidence: MEDIUM
      likelihood: LOW
      impact: MEDIUM

  # ============================================================================
  # Rule 7: Rich Console Output Sanitization (Phase 1 Enhancement)
  # ============================================================================
  - id: missing-string-sanitization-rich-console
    patterns:
      - pattern-either:
          - pattern: $CONSOLE.print($MSG, ...)
          - pattern: Console(...).print($MSG, ...)
      - pattern-not: $CONSOLE.print(Table(...), ...)
      - pattern-not: $CONSOLE.print(Panel(...), ...)
      - pattern-not: $CONSOLE.print(Group(...), ...)
      - pattern-not: $CONSOLE.print()
    message: |
      Rich console output containing user input should use sanitize_string() to prevent injection attacks.

      This is a reminder to review console.print() calls for user input.

      Example of safe usage:
        sanitized = sanitize_string(user_input, context="error")
        console.print(f"[red]Error: {sanitized}[/red]")

      Exception: Rich objects (Table, Panel, Group) have built-in escaping.

      See docs/guides/SECURITY.md for sanitization contexts.
    languages: [python]
    severity: INFO
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
    metadata:
      category: security
      cwe: "CWE-74: Injection"
      owasp: "A03:2021 - Injection"
      confidence: LOW
      likelihood: LOW
      impact: MEDIUM

  # ============================================================================
  # Rule 8: HTTPS Enforcement for URL Requests (Phase 1 Enhancement)
  # ============================================================================
  - id: missing-https-validation
    pattern-either:
      - pattern: urllib.request.urlopen($URL, ...)
      - pattern: urllib.request.Request($URL, ...)
    message: |
      URL requests should be validated to ensure HTTPS-only communication.

      This project enforces HTTPS-only for all API calls.
      Review this usage to ensure HTTPS validation is present.

      Reference implementation: vscode_scanner/vscan_api.py

      See docs/guides/SECURITY.md for network security requirements.
    languages: [python]
    severity: INFO
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
        - "**/vscan_api.py"  # Already implements HTTPS validation
    metadata:
      category: security
      cwe: "CWE-319: Cleartext Transmission"
      owasp: "A02:2021 - Cryptographic Failures"
      confidence: MEDIUM
      likelihood: LOW
      impact: HIGH

  # ============================================================================
  # Rule 9: Hardcoded Secrets Detection (Phase 3)
  # ============================================================================
  - id: hardcoded-secrets
    patterns:
      - pattern-either:
          - pattern: $VAR = "..."
          - pattern: $VAR = '...'
      - metavariable-regex:
          metavariable: $VAR
          regex: (?i)(api[_-]?key|password|secret[_-]?key|access[_-]?key|auth[_-]?token|private[_-]?key|secret|token|credentials)
      - pattern-not: $VAR = ""
      - pattern-not: $VAR = "test"
      - pattern-not: $VAR = "placeholder"
      - pattern-not: $VAR = "your-api-key-here"
      - pattern-not: $VAR = "YOUR_API_KEY"
      - pattern-not: $VAR = "***"
    message: |
      Potential hardcoded secret detected.

      Hardcoded secrets in code pose serious security risks:
      - Secrets exposed in version control
      - Cannot be rotated without code changes
      - Risk of exposure in logs, error messages, backups

      Best practices:
      - Use environment variables: os.getenv("API_KEY")
      - Use configuration files outside version control
      - Use secret management services (Vault, AWS Secrets Manager)
      - Never commit secrets to git

      If this is a placeholder or test value, add a comment explaining it.
    languages: [python]
    severity: ERROR
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
    metadata:
      category: security
      cwe: "CWE-798: Hard-coded Credentials"
      owasp: "A07:2021 - Identification and Authentication Failures"
      confidence: MEDIUM
      likelihood: HIGH
      impact: CRITICAL

  # ============================================================================
  # Rule 10: Insecure Deserialization (Phase 3)
  # ============================================================================
  - id: insecure-deserialization
    patterns:
      - pattern-either:
          - pattern: pickle.loads(...)
          - pattern: pickle.load(...)
          - pattern: yaml.load($DATA)
          - pattern: yaml.load($DATA, ...)
          - pattern: marshal.loads(...)
          - pattern: marshal.load(...)
      - pattern-not: yaml.load($DATA, Loader=yaml.SafeLoader)
      - pattern-not: yaml.load($DATA, Loader=yaml.BaseLoader)
    message: |
      Insecure deserialization detected.

      Deserialization of untrusted data can lead to:
      - Arbitrary code execution
      - Object injection attacks
      - Denial of service

      Security recommendations:
      - pickle: Never deserialize untrusted data (fundamentally unsafe)
      - yaml: Use yaml.safe_load() or yaml.load(data, Loader=yaml.SafeLoader)
      - marshal: Avoid for untrusted data, use JSON instead
      - json: Safe for deserialization (use json.loads())

      If you must use pickle/yaml.load, ensure data source is fully trusted
      and add security controls (signature verification, sandboxing).
    languages: [python]
    severity: ERROR
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
    metadata:
      category: security
      cwe: "CWE-502: Deserialization of Untrusted Data"
      owasp: "A08:2021 - Software and Data Integrity Failures"
      confidence: HIGH
      likelihood: MEDIUM
      impact: CRITICAL

  # ============================================================================
  # Rule 11: Threading Race Conditions (Phase 3)
  # ============================================================================
  - id: threading-race-condition
    patterns:
      - pattern-either:
          - pattern: |
              class $CLASS:
                ...
                $ATTR = ...
                ...
                def $METHOD(self, ...):
                  ...
                  self.$ATTR = ...
                  ...
          - pattern: |
              $GLOBAL = ...
              ...
              def $FUNC(...):
                ...
                global $GLOBAL
                ...
                $GLOBAL = ...
                ...
      - pattern-not-inside: |
          ...
          with $LOCK:
            ...
      - pattern-not-inside: |
          ...
          $LOCK.acquire()
          ...
          $LOCK.release()
          ...
    message: |
      Potential threading race condition detected.

      Shared mutable state without synchronization can cause:
      - Data corruption
      - Inconsistent state
      - Hard-to-reproduce bugs

      This project uses parallel processing (ThreadPoolExecutor).
      All shared state MUST be protected with locks.

      Best practices:
      - Use threading.Lock() for shared mutable state
      - Use ThreadSafeStats class pattern (see vscode_scanner/scanner.py)
      - Prefer immutable data structures
      - Use thread-local storage when possible
      - Document thread-safety guarantees

      Example safe pattern:
        class ThreadSafeCounter:
          def __init__(self):
            self._lock = threading.Lock()
            self._count = 0

          def increment(self):
            with self._lock:
              self._count += 1

      See docs/guides/PERFORMANCE.md for threading architecture details.
    languages: [python]
    severity: WARNING
    paths:
      include:
        - vscode_scanner/
      exclude:
        - tests/
        - "**/scanner.py"  # Already uses ThreadSafeStats with proper locking
    metadata:
      category: security
      cwe: "CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization"
      owasp: "A04:2021 - Insecure Design"
      confidence: LOW
      likelihood: MEDIUM
      impact: MEDIUM
