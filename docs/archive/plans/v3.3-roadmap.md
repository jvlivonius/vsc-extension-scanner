# V3.3 UX Enhancement Plan
**Date:** 2025-10-25
**Current Version:** 3.3.0
**Target Version:** 3.3.1
**Status:** ðŸ”„ IN PROGRESS - v3.3.1
**Focus Areas:** Date Tracking, Enhanced Filtering, Data Enrichment (v3.3.1)

---

## Executive Summary

This document outlines the v3.3 release plan for the VS Code Extension Scanner. Version 3.3 focuses on **improving user experience through cleaner output, better error reporting, and configuration flexibility** while maintaining full backward compatibility.

**v3.3.0 Status:** âœ… Completed and Released

**v3.3.0 Goals (All Delivered):**
1. **Security-Focused Output** - Hide operational details by default, show security findings prominently âœ…
2. **Failed Extension Transparency** - Clearly report which extensions failed to scan and why âœ…
3. **Configuration Flexibility** - Support custom extension directory in config file âœ…

**v3.3.1 Status:** ðŸ”„ IN PROGRESS

**v3.3.1 Goals:**
1. **Installation Date Tracking** - Track and display when extensions were installed ðŸ”„
2. **Last Scan Date Tracking** - Show when each extension was last scanned ðŸ”„
3. **Enhanced CLI Filtering** - Filter by verified status and vulnerability presence ðŸ”„

**Guiding Principles:**
- **Rich/Plain Compatibility** - Every feature must work perfectly in both Rich and plain output modes
- **KISS Architecture** - No over-engineering, simple and maintainable solutions
- **Backward Compatible** - All new features are opt-in or enhancement-only
- **Fail Fast with Helpful Guidance** - Better error messages with actionable suggestions

---

## Feature Specifications

### Feature 1: Extension Directory in Config File

**Priority:** HIGH (Foundation)
**Complexity:** LOW
**Estimated Effort:** 2-3 hours

**Problem:**
Users with custom VS Code installations or multiple extension directories must specify `--extensions-dir` on every scan. This is tedious and error-prone.

**Solution:**
Add `extensions_dir` option to `[scan]` section in `~/.vscanrc` config file.

**Configuration Example:**
```ini
[scan]
# Custom VS Code extensions directory (optional)
# extensions_dir = ~/.vscode/extensions  # Default
extensions_dir = ~/custom/vscode/extensions
```

**Implementation Details:**
- **Type:** `path` (supports ~ expansion)
- **Validation:** Lazy (validate on scan, not on config set) - allows setting paths that don't exist yet
- **Priority:** CLI argument > config file > auto-detect
- **Config Schema:** Add to `CONFIG_SCHEMA` and `DEFAULT_CONFIG` in `config_manager.py`

**Files Modified:**
1. `vscode_scanner/config_manager.py`:
   - Add `extensions_dir` to `CONFIG_SCHEMA['scan']`
   - Add to `DEFAULT_CONFIG['scan']` with `None` default
   - Add to `DEFAULT_CONFIG_TEMPLATE` with commented example

2. `vscode_scanner/cli.py`:
   - Load `extensions_dir` from config if not specified via CLI
   - Apply same precedence as other config options

**Rich/Plain Compatibility:**
- Config display commands (`vscan config show`) already support both modes
- No special display logic needed (path is plain text)

**Testing:**
- Set and get `extensions_dir` via config commands
- Verify CLI argument overrides config value
- Verify auto-detect works when config is `None`
- Test path expansion (~ to home directory)

**Success Criteria:**
- âœ… Can set custom directory in config file
- âœ… CLI argument takes precedence over config
- âœ… Auto-detect still works when not configured
- âœ… Path validation only happens during scan

---

### Feature 2: Enhanced Verbose Mode

**Priority:** HIGH (Foundation)
**Complexity:** MEDIUM
**Estimated Effort:** 4-6 hours

**Problem:**
Standard output mixes security findings with operational details (retry stats, cache info, timing). Users focused on security must wade through technical information.

**Solution:**
Create three distinct output modes:
1. **Quiet Mode** (`--quiet`) - Single-line summary only (existing)
2. **Standard Mode** (default, NEW) - Security findings only, hide operational details
3. **Verbose Mode** (`--verbose`) - Security + operational details (enhanced)

**Standard Mode Output (NEW):**
```
Scanning 66 extensions...
[=========>          ] 25/66

âœ“ Scan Complete

Security Summary:
â€¢ Total extensions: 66
â€¢ Vulnerabilities found: 3 (4.5%)
  - High risk: 2
  - Medium risk: 1

Report saved: report.html
```

**Verbose Mode Output (Enhanced):**
```
Scanning 66 extensions...
[=========>          ] 25/66 (âš¡ 18 cached, ðŸ” 7 fresh)

Cache Statistics:
â€¢ Hit rate: 72%
â€¢ Cached: 48, Fresh: 18
â€¢ Age distribution: ...

Retry Statistics:
â€¢ Total retries: 12
â€¢ Successful: 11
â€¢ Failed: 1

âœ“ Scan Complete (took 45.2s, avg 0.68s/ext)

Security Summary:
â€¢ Total extensions: 66
â€¢ Vulnerabilities found: 3 (4.5%)
  - High risk: 2
  - Medium risk: 1

Report saved: report.html
```

**What Gets Hidden in Standard Mode:**
- âŒ Per-extension cache symbols (âš¡/ðŸ”)
- âŒ Cache statistics (hit rate, age distribution, risk breakdown)
- âŒ Retry statistics (HTTP retries, workflow retries)
- âŒ Timing information (scan duration, avg time per extension)
- âœ… Progress bar (kept - shows user scan is active)
- âœ… Security findings (kept - primary focus)
- âœ… File output confirmation (kept - important feedback)

**Implementation Strategy:**
```python
# scanner.py - Split summary into 3 modes
def _print_summary(extensions, stats, duration, use_rich, results, quiet, verbose):
    if quiet:
        _print_quiet_summary(...)      # Existing: minimal single-line
    elif verbose:
        _print_verbose_summary(...)    # Enhanced: show everything
    else:
        _print_standard_summary(...)   # NEW: security-focused only

# Each mode has Rich and Plain variants
def _print_standard_summary(stats, use_rich):
    if use_rich:
        _print_standard_summary_rich(stats)
    else:
        _print_standard_summary_plain(stats)

def _print_verbose_summary(stats, cache_stats, retry_stats, duration, use_rich):
    if use_rich:
        _print_verbose_summary_rich(...)
    else:
        _print_verbose_summary_plain(...)
```

**Rich/Plain Compatibility Matrix:**

| Element | Rich Mode | Plain Mode |
|---------|-----------|------------|
| Section headings | Rich Panel with colors | Text with `===` separator |
| Security summary | Rich Table with colors | Plain text with bullets |
| Cache stats (verbose) | Rich Table | Plain text table |
| Retry stats (verbose) | Rich Table | Plain text with indentation |
| Colors | Risk-based colors (red/yellow/green) | No colors |

**Files Modified:**
1. `vscode_scanner/scanner.py`:
   - Split `_print_summary()` into mode-specific functions
   - Add verbose flag checks before displaying operational info
   - Create `_print_standard_summary()` for security-focused output
   - Enhance `_print_verbose_summary()` with all details

2. `vscode_scanner/display.py`:
   - Add `create_security_summary_table(stats, use_rich)`
   - Add `create_verbose_details_table(cache_stats, retry_stats, use_rich)`
   - Ensure all functions have Rich and Plain variants

3. `vscode_scanner/cli.py`:
   - Update `--verbose` help text to clarify it shows operational details
   - Add examples to help text

**Testing Requirements:**
Test all combinations (3 modes Ã— 2 formats = 6 test cases):
1. Quiet + Rich
2. Quiet + Plain
3. Standard + Rich (NEW)
4. Standard + Plain (NEW)
5. Verbose + Rich
6. Verbose + Plain

**Verification:**
- Run scan with vulnerabilities found
- Verify standard mode hides cache/retry/timing info
- Verify verbose mode shows all details
- Check both Rich and Plain outputs for each mode

**Success Criteria:**
- âœ… Standard mode shows security findings prominently
- âœ… Operational details hidden in standard mode
- âœ… Verbose mode shows all information
- âœ… Both Rich and Plain modes work correctly
- âœ… Help text clearly explains modes

---

### Feature 3: Failed Extensions Tracking & Reporting

**Priority:** MEDIUM (UX Enhancement)
**Complexity:** MEDIUM
**Estimated Effort:** 5-7 hours

**Problem:**
When extensions fail to scan (API errors, rate limits, timeouts), users only see a count. They don't know which extensions failed or why, making it difficult to troubleshoot or retry specific extensions.

**Solution:**
Track failed extensions during scan and display a summary table with extension names and error categories. Provide actionable suggestions for resolution.

**Display Format (Rich Mode):**
```
âš  Failed to Scan (3 extensions)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Extension                    â”‚ Error           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ms-python.python             â”‚ API error       â”‚
â”‚ esbenp.prettier-vscode       â”‚ Rate limit      â”‚
â”‚ local.test-extension         â”‚ Network timeout â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Suggestion: Re-run with --delay 3.0 or --max-retries 5
```

**Display Format (Plain Mode):**
```
âš  Failed to Scan (3 extensions)
========================================
ms-python.python - API error
esbenp.prettier-vscode - Rate limit
local.test-extension - Network timeout

Suggestion: Re-run with --delay 3.0 or --max-retries 5
```

**JSON Schema Addition:**
```json
{
  "summary": {
    "total_extensions_scanned": 66,
    "failed_scans": 3,
    "failed_extensions": [
      {
        "id": "ms-python.python",
        "name": "Python",
        "error_type": "api_error",
        "error_message": "API error"
      },
      {
        "id": "esbenp.prettier-vscode",
        "name": "Prettier - Code formatter",
        "error_type": "rate_limit",
        "error_message": "Rate limit"
      }
    ]
  }
}
```

**Error Categorization:**

Simple categorization for user-friendly display:
- `rate_limit` - HTTP 429 or "rate limit" in error message
- `network_timeout` - "timeout" in error message
- `network_error` - "network" or "connection" in error message
- `api_error` - Generic catch-all for other API errors

**Implementation:**

```python
# scanner.py - Track failures during scan
stats = {
    'scanned_count': 0,
    'cached_results': 0,
    'fresh_scans': 0,
    'vulnerabilities_found': 0,
    'failed_scans': 0,
    'failed_extensions': []  # NEW: List of dicts
}

# In _scan_extensions() - Capture failures
try:
    result = api_client.scan_extension(...)
    # ... handle success ...
except Exception as e:
    stats['failed_scans'] += 1
    stats['failed_extensions'].append({
        'id': ext['id'],
        'name': ext.get('name', ext['id']),
        'error_type': _categorize_error(e),
        'error_message': _simplify_error_message(e)
    })
    log(f"Failed to scan {ext['id']}: {e}", "WARNING")
    continue  # Continue scanning other extensions

# Error categorization helper
def _categorize_error(exception: Exception) -> str:
    """Categorize exception into user-friendly error type."""
    error_str = str(exception).lower()

    if 'rate limit' in error_str or '429' in error_str:
        return 'rate_limit'
    elif 'timeout' in error_str:
        return 'network_timeout'
    elif 'network' in error_str or 'connection' in error_str:
        return 'network_error'
    else:
        return 'api_error'

def _simplify_error_message(error_type: str) -> str:
    """Convert error type to user-friendly message."""
    messages = {
        'rate_limit': 'Rate limit',
        'network_timeout': 'Network timeout',
        'network_error': 'Network error',
        'api_error': 'API error'
    }
    return messages.get(error_type, 'API error')

# Display failures if any exist
if stats['failed_extensions']:
    if use_rich:
        display.display_failed_extensions_rich(stats['failed_extensions'])
    else:
        display.display_failed_extensions_plain(stats['failed_extensions'])
```

**Rich/Plain Implementation:**

```python
# display.py

def display_failed_extensions_rich(failed_extensions: List[Dict]) -> None:
    """Display failed extensions in Rich format."""
    from rich.console import Console
    from rich.table import Table

    console = Console()

    # Warning header
    console.print(f"\n[yellow]âš  Failed to Scan ({len(failed_extensions)} extensions)[/yellow]\n")

    # Create table
    table = Table(show_header=True, header_style="bold yellow")
    table.add_column("Extension", style="cyan")
    table.add_column("Error", style="red")

    for ext in failed_extensions:
        table.add_row(ext['name'], ext['error_message'])

    console.print(table)

    # Suggestion
    console.print("\n[dim]Suggestion: Re-run with --delay 3.0 or --max-retries 5[/dim]\n")

def display_failed_extensions_plain(failed_extensions: List[Dict]) -> None:
    """Display failed extensions in plain format."""
    print(f"\nâš  Failed to Scan ({len(failed_extensions)} extensions)")
    print("=" * 60)

    for ext in failed_extensions:
        print(f"{ext['name']} - {ext['error_message']}")

    print("\nSuggestion: Re-run with --delay 3.0 or --max-retries 5\n")
```

**Files Modified:**
1. `vscode_scanner/scanner.py`:
   - Add `failed_extensions` list to stats dict
   - Capture failures in exception handlers
   - Add `_categorize_error()` and `_simplify_error_message()` helpers
   - Call display functions if failures exist

2. `vscode_scanner/display.py`:
   - Add `display_failed_extensions_rich()`
   - Add `display_failed_extensions_plain()`

3. `vscode_scanner/output_formatter.py`:
   - Add `failed_extensions` to JSON schema in `format_output()`
   - Include in summary section

**Testing Requirements:**
- Mock API to return different error types (rate limit, timeout, network, generic)
- Verify error categorization works correctly
- Test Rich mode table display
- Test Plain mode list display
- Verify JSON output includes failed_extensions array
- Test empty failures (no display shown)
- Test mixed success/failure scenarios

**Success Criteria:**
- âœ… Failed extensions tracked during scan
- âœ… Clear display in both Rich and Plain modes
- âœ… Error categorization is accurate
- âœ… JSON output includes detailed failure info
- âœ… Helpful suggestions provided
- âœ… No display when all scans succeed

---

## V3.3.1 Features (Date Tracking & Enhanced Filtering)

The following features were added in v3.3.1 to provide better temporal context for extension installations and scans, plus enhanced filtering capabilities.

---

### Feature 5: Installation & Scan Date Tracking

**Priority:** MEDIUM (Data Enrichment)
**Complexity:** MEDIUM
**Estimated Effort:** 8-10 hours

**Problem:**
Users have no visibility into when extensions were installed or when they were last scanned for vulnerabilities. This temporal information is valuable for:
- Security audits (identifying recently installed extensions)
- Cache freshness awareness (knowing if scan data is stale)
- Compliance tracking (documenting when extensions were reviewed)

**Solution:**
Track and display two new date fields for each extension:
1. **Installation Date** - Parse from `~/.vscode/extensions/extensions.json` file
2. **Last Scan Date** - Track from cache timestamp or current scan time

Display in all output formats (JSON, CSV, HTML) with consistent date formatting.

**Data Source - Installation Date:**

VS Code stores installation metadata in `~/.vscode/extensions/extensions.json`:
```json
{
  "identifier": {"id": "ms-python.python"},
  "version": "2025.16.0",
  "metadata": {
    "installedTimestamp": 1732710384833,  // Unix timestamp in milliseconds
    "source": "gallery",
    "publisherDisplayName": "Microsoft"
  }
}
```

**Implementation Strategy:**

```python
# extension_discovery.py - Parse extensions.json

def _read_extensions_json(self, extensions_dir: Path) -> Dict[str, int]:
    """
    Read installation timestamps from extensions.json.

    Returns:
        Dict mapping extension ID to installation timestamp (Unix ms)
    """
    json_path = extensions_dir / "extensions.json"

    if not json_path.exists():
        log("extensions.json not found, installation dates unavailable", "WARNING")
        return {}

    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        timestamps = {}
        for entry in data:
            ext_id = entry.get('identifier', {}).get('id')
            installed = entry.get('metadata', {}).get('installedTimestamp')

            if ext_id and installed:
                timestamps[ext_id] = installed

        return timestamps

    except (json.JSONDecodeError, IOError) as e:
        log(f"Failed to parse extensions.json: {sanitize_error_message(str(e))}", "WARNING")
        return {}

def discover_extensions(self) -> List[Dict[str, str]]:
    """Discover extensions with installation dates."""
    extensions_dir = self.find_extensions_directory()

    # Get installation timestamps
    install_timestamps = self._read_extensions_json(extensions_dir)

    extensions = []
    for ext_dir in extensions_dir.iterdir():
        # ... existing discovery logic ...

        metadata = self._parse_extension(ext_dir)
        if metadata:
            # Add installation timestamp
            ext_id = metadata['id']
            if ext_id in install_timestamps:
                # Convert Unix ms to ISO format
                timestamp_ms = install_timestamps[ext_id]
                timestamp_sec = timestamp_ms / 1000
                installed_at = datetime.fromtimestamp(timestamp_sec).isoformat() + 'Z'
                metadata['installed_at'] = installed_at

            extensions.append(metadata)

    return extensions
```

**Cache Schema Update (v2.0 â†’ v2.1):**

```python
# cache_manager.py - Add installed_at column

def _migrate_v2_0_to_v2_1(self):
    """Migrate from schema v2.0 to v2.1 (add installed_at)."""
    with self._db_connection() as conn:
        cursor = conn.cursor()

        # Add new column
        cursor.execute("""
            ALTER TABLE scan_cache
            ADD COLUMN installed_at TIMESTAMP
        """)

        # Update schema version
        cursor.execute(
            "UPDATE metadata SET value = '2.1' WHERE key = 'schema_version'"
        )

        conn.commit()
```

**JSON Output Format:**

```json
{
  "extensions": [
    {
      "id": "ms-python.python",
      "name": "python",
      "version": "2025.16.0",
      "installed_at": "2024-11-27T10:26:24Z",
      "last_scanned_at": "2025-10-24T14:30:00Z",
      "security": { ... }
    }
  ]
}
```

**CSV Output Format:**

Add two new columns at the end (columns 16 & 17):
```csv
Extension ID,Name,Version,...,Last Updated,Installed Date,Last Scanned Date
ms-python.python,Python,2025.16.0,...,2025-10-15,2024-11-27T10:26:24Z,2025-10-24T14:30:00Z
```

**HTML Report Format:**

Add two new columns to the extensions table (hidden by default, sortable):

```html
<!-- Column toggles -->
<div class="column-dropdown-item">
    <input type="checkbox" id="col-installed" onchange="toggleColumn('installed')">
    <label for="col-installed">Installed</label>
</div>
<div class="column-dropdown-item">
    <input type="checkbox" id="col-last-scanned" onchange="toggleColumn('last-scanned')">
    <label for="col-last-scanned">Last Scanned</label>
</div>

<!-- Table headers -->
<th class="col-installed sortable" onclick="sortTable('installed')" style="display: none;">
    Installed <span class="sort-indicator"></span>
</th>
<th class="col-last-scanned sortable" onclick="sortTable('last-scanned')" style="display: none;">
    Last Scanned <span class="sort-indicator"></span>
</th>

<!-- Table cells -->
<td class="col-installed" style="display: none;">
    <span class="date-value" data-iso-date="2024-11-27T10:26:24Z">2024-11-27T10:26:24Z</span>
</td>
<td class="col-last-scanned" style="display: none;">
    <span class="date-value" data-iso-date="2025-10-24T14:30:00Z">2025-10-24T14:30:00Z</span>
</td>
```

**Date Formatting:**
- Use existing `formatDates()` JavaScript function
- Locale-aware formatting: `date.toLocaleString()`
- Consistent with existing date display behavior

**Files Modified:**

1. `vscode_scanner/extension_discovery.py`:
   - Add `_read_extensions_json()` method
   - Update `discover_extensions()` to include installation dates

2. `vscode_scanner/cache_manager.py`:
   - Add `installed_at` column to schema (v2.1)
   - Create migration function `_migrate_v2_0_to_v2_1()`
   - Update `save_result()` and `save_result_batch()` to store installed_at
   - Update `get_cached_result()` to return installed_at

3. `vscode_scanner/scanner.py`:
   - Pass installation dates through scan pipeline
   - Ensure timestamps propagate to results

4. `vscode_scanner/output_formatter.py`:
   - Add `installed_at` and `last_scanned_at` to JSON output
   - Update `format_csv()` to add two new columns

5. `vscode_scanner/html_report_generator.py`:
   - Add checkboxes for new columns in `_generate_controls()`
   - Add column headers in `_generate_overview_table()`
   - Add data cells with date-value class
   - Update colspan from 11 to 13 in detail rows

**Error Handling:**

- Missing extensions.json: Log warning, continue with NULL installation dates
- Corrupt JSON: Log warning, skip installation date tracking
- Missing timestamp field: Skip that extension's install date
- Invalid timestamp values: Skip that extension's install date

**Testing Requirements:**

1. **Unit Tests:**
   - Parse valid extensions.json
   - Handle missing extensions.json
   - Handle corrupt JSON
   - Handle missing installedTimestamp field
   - Date format conversion (Unix ms â†’ ISO)

2. **Integration Tests:**
   - Full scan with installation dates
   - Cache storage and retrieval of dates
   - JSON output includes dates
   - CSV output includes dates
   - HTML report displays dates correctly

3. **Manual Testing:**
   ```bash
   # Test all output formats
   vscan scan --output results.json
   vscan scan --output results.csv
   vscan scan --output report.html

   # Verify HTML columns
   # - Open report.html
   # - Click column toggle
   # - Enable "Installed" and "Last Scanned"
   # - Verify sorting works
   ```

**Success Criteria:**

- âœ… Installation dates parsed from extensions.json
- âœ… Last scan dates tracked from cache
- âœ… JSON output includes `installed_at` and `last_scanned_at`
- âœ… CSV includes two new date columns
- âœ… HTML report has two new sortable columns (hidden by default)
- âœ… Dates formatted consistently (locale-aware in HTML)
- âœ… Cache schema upgraded without data loss (v2.0 â†’ v2.1)
- âœ… Graceful handling of missing/corrupt extensions.json
- âœ… Backward compatible with v3.3.0

---

### Feature 6: Enhanced CLI Filtering

**Priority:** MEDIUM (UX Enhancement)
**Complexity:** LOW
**Estimated Effort:** 2-3 hours

**Problem:**
Users cannot filter extensions by common criteria before scanning, leading to:
- Unnecessary API calls for extensions they don't care about
- Cluttered output with unwanted results
- Difficulty focusing on specific security concerns

**Solution:**
Add CLI flags to filter extensions by publisher verification status and vulnerability presence.

**New CLI Flags:**

```bash
# Filter by publisher verification
vscan scan --verified-only          # Only verified publishers
vscan scan --unverified-only        # Only unverified publishers

# Filter by vulnerability presence
vscan scan --with-vulnerabilities   # Only extensions with known vulnerabilities
vscan scan --without-vulnerabilities # Only clean extensions

# Combine filters
vscan scan --verified-only --without-vulnerabilities  # Verified and clean
```

**Implementation Strategy:**

```python
# cli.py - Add new arguments

@app.command()
def scan(
    # ... existing arguments ...
    verified_only: bool = typer.Option(
        False,
        "--verified-only",
        help="Only show extensions from verified publishers"
    ),
    unverified_only: bool = typer.Option(
        False,
        "--unverified-only",
        help="Only show extensions from unverified publishers"
    ),
    with_vulnerabilities: bool = typer.Option(
        False,
        "--with-vulnerabilities",
        help="Only show extensions with known vulnerabilities"
    ),
    without_vulnerabilities: bool = typer.Option(
        False,
        "--without-vulnerabilities",
        help="Only show extensions without vulnerabilities"
    )
):
    # Validate conflicting filters
    if verified_only and unverified_only:
        display_error("Cannot use --verified-only and --unverified-only together")
        sys.exit(2)

    if with_vulnerabilities and without_vulnerabilities:
        display_error("Cannot use --with-vulnerabilities and --without-vulnerabilities together")
        sys.exit(2)

    # ... rest of scan command ...
```

**Filtering Logic:**

```python
# scanner.py - Apply filters after scanning

def _apply_filters(results, args):
    """Apply CLI filters to scan results."""
    filtered = results

    # Filter by publisher verification
    if args.verified_only:
        filtered = [r for r in filtered
                   if r.get('metadata', {}).get('publisher', {}).get('verified', False)]

    if args.unverified_only:
        filtered = [r for r in filtered
                   if not r.get('metadata', {}).get('publisher', {}).get('verified', False)]

    # Filter by vulnerability presence
    if args.with_vulnerabilities:
        filtered = [r for r in filtered
                   if r.get('vulnerabilities', {}).get('count', 0) > 0]

    if args.without_vulnerabilities:
        filtered = [r for r in filtered
                   if r.get('vulnerabilities', {}).get('count', 0) == 0]

    return filtered
```

**Filter Timing:**

- Publisher verification: Filter **after** API call (requires vscan.dev data)
- Vulnerability presence: Filter **after** API call (requires vscan.dev data)
- Both filters applied in post-processing phase

**Output Behavior:**

```bash
$ vscan scan --verified-only
Scanning 66 extensions...
[=========>          ] 66/66

Filters applied:
  â€¢ Publisher: Verified only

âœ“ Scan Complete

Security Summary:
â€¢ Total extensions: 66
â€¢ Matching filters: 45 (68.2%)
â€¢ Filtered out: 21 (31.8%)
â€¢ Vulnerabilities found: 2
```

**Files Modified:**

1. `vscode_scanner/cli.py`:
   - Add 4 new CLI arguments with validation
   - Pass filter flags to scanner

2. `vscode_scanner/scanner.py`:
   - Add `_apply_filters()` function
   - Apply filters after scanning
   - Update summary stats to show filter counts

3. `vscode_scanner/display.py`:
   - Add filter summary display (Rich and Plain modes)

**Testing Requirements:**

1. **Unit Tests:**
   - Filter validation (conflicting flags)
   - Filter logic (verified/unverified)
   - Filter logic (with/without vulnerabilities)
   - Combined filters

2. **Integration Tests:**
   - Full scan with each filter
   - Combined filters
   - Verify correct extension count
   - Verify JSON/CSV/HTML only include filtered results

3. **Manual Testing:**
   ```bash
   # Test individual filters
   vscan scan --verified-only
   vscan scan --unverified-only
   vscan scan --with-vulnerabilities
   vscan scan --without-vulnerabilities

   # Test combinations
   vscan scan --verified-only --without-vulnerabilities
   vscan scan --unverified-only --with-vulnerabilities

   # Test conflicts (should error)
   vscan scan --verified-only --unverified-only  # Error
   vscan scan --with-vulnerabilities --without-vulnerabilities  # Error
   ```

**Success Criteria:**

- âœ… All 4 filter flags implemented
- âœ… Conflicting filters detected and rejected
- âœ… Filters apply correctly to results
- âœ… Filter summary displayed in output
- âœ… JSON/CSV/HTML only include filtered extensions
- âœ… Filter counts accurate
- âœ… Works in both Rich and Plain modes
- âœ… Help text clear and includes examples

---

## Feature 4: Deferred to v3.4

**Parallel Scanning** was originally planned for v3.3 but has been deferred to v3.4.0 due to its higher complexity and optional nature.

**Reason for Deferral:**
- Higher implementation complexity (12-16 hours vs 2-6 hours for other features)
- Requires extensive thread-safety testing
- Optional feature (not critical for core UX improvements)
- Time better spent ensuring quality of delivered features

**Status:** Full specification moved to `docs/project/v3.4-ROADMAP.md`

---

## Implementation Phases

### Phase 1: Documentation Setup (2 hours)

**Tasks:**
1. âœ… Create `docs/project/v3.3-ROADMAP.md` (this document)
2. Clean up `docs/project/STATUS.md`
   - Archive verbose details to `docs/archive/summaries/`
   - Keep only current version and v3.2 summary (5-10 lines)
   - Reduce from ~1400 lines to ~150-200 lines
3. Update `docs/project/PRD.md` to version 3.3.0
   - Add Feature 3.7: Failed Extensions Reporting
   - Add Feature 3.8: Parallel Scanning
   - Update CLI examples
   - Update config file examples
4. Update `CLAUDE.md` current status

**Deliverables:**
- âœ… v3.3 ROADMAP created
- âœ… STATUS.md cleaned up
- âœ… PRD.md updated
- âœ… CLAUDE.md updated

---

### Phase 2: Foundation Features (6-8 hours)

**Feature 1: Extension Directory in Config** (2-3 hours)

**Tasks:**
1. Update `config_manager.py`:
   - Add `extensions_dir` to `CONFIG_SCHEMA['scan']`
   - Add to `DEFAULT_CONFIG['scan']` (None default)
   - Add to `DEFAULT_CONFIG_TEMPLATE` with comment
2. Update `cli.py`:
   - Load from config if CLI arg not provided
   - Verify precedence: CLI > config > auto-detect
3. Testing:
   - Config set/get extensions_dir
   - CLI override
   - Path expansion (~)

**Feature 2: Enhanced Verbose Mode** (4-6 hours)

**Tasks:**
1. Update `scanner.py`:
   - Split `_print_summary()` into 3 mode functions
   - Implement `_print_standard_summary()` (security-focused)
   - Enhance `_print_verbose_summary()` (all details)
   - Each function supports Rich and Plain
2. Update `display.py`:
   - Add `create_security_summary_table(stats, use_rich)`
   - Add Rich and Plain variants
3. Update `cli.py`:
   - Update `--verbose` help text
4. Testing:
   - Test 6 combinations (3 modes Ã— 2 formats)
   - Verify operational info hidden in standard
   - Verify all info shown in verbose

**Deliverables:**
- âœ… Extension directory configurable
- âœ… Three distinct output modes working
- âœ… Both Rich and Plain modes tested

---

### Phase 3: UX Enhancements (8-12 hours)

**Feature 3: Failed Extensions Tracking** (8-12 hours)

**Tasks:**
1. Update `scanner.py`:
   - Add `failed_extensions` list to stats
   - Capture failures in exception handlers
   - Add `_categorize_error()` helper
   - Add `_simplify_error_message()` helper
   - Display failures if any exist
2. Update `display.py`:
   - Implement `display_failed_extensions_rich()`
   - Implement `display_failed_extensions_plain()`
3. Update `output_formatter.py`:
   - Add `failed_extensions` to JSON schema
4. Testing:
   - Mock different error types
   - Test Rich table display
   - Test Plain list display
   - Verify JSON output
   - Test empty failures

**Deliverables:**
- âœ… Failed extensions tracked and displayed
- âœ… Error categorization working
- âœ… Both Rich and Plain displays tested
- âœ… JSON output includes failures

---

### Phase 4: Date Tracking & Enhanced Filtering (13-19 hours) - v3.3.1

**Feature 5: Installation & Scan Date Tracking** (8-10 hours)

**Tasks:**
1. Update `extension_discovery.py`:
   - Add `_read_extensions_json()` method to parse extensions.json
   - Parse `installedTimestamp` from metadata
   - Convert Unix ms timestamps to ISO format
   - Add installation date to extension metadata
   - Handle missing/corrupt extensions.json gracefully

2. Update `cache_manager.py`:
   - Create schema migration v2.0 â†’ v2.1
   - Add `installed_at` TIMESTAMP column
   - Update `save_result()` to store installed_at
   - Update `save_result_batch()` to store installed_at
   - Update `get_cached_result()` to return installed_at
   - Test migration with existing cache data

3. Update `scanner.py`:
   - Pass installation dates through scan pipeline
   - Ensure timestamps propagate to results
   - Add last_scanned_at field (from cache or current time)

4. Update `output_formatter.py`:
   - Add `installed_at` field to JSON output
   - Add `last_scanned_at` field to JSON output
   - Update `format_csv()` to add two new columns (16 & 17)
   - Ensure ISO format for all dates

5. Update `html_report_generator.py`:
   - Add "Installed" checkbox in `_generate_controls()`
   - Add "Last Scanned" checkbox in `_generate_controls()`
   - Add column headers in `_generate_overview_table()` (hidden by default)
   - Add data cells with date-value class
   - Update colspan from 11 to 13 in detail rows
   - Verify sortTable() handles date columns correctly

6. Testing:
   - Unit tests for extensions.json parsing
   - Unit tests for date format conversion
   - Unit tests for cache migration
   - Integration test: full scan with dates
   - Integration test: JSON/CSV/HTML output
   - Manual test: HTML column toggle and sorting

**Feature 6: Enhanced CLI Filtering** (2-3 hours)

**Tasks:**
1. Update `cli.py`:
   - Add `--verified-only` flag
   - Add `--unverified-only` flag
   - Add `--with-vulnerabilities` flag
   - Add `--without-vulnerabilities` flag
   - Add validation for conflicting flags
   - Update help text with examples

2. Update `scanner.py`:
   - Add `_apply_filters()` function
   - Apply filters after scanning (post-processing)
   - Update summary stats to show filter counts
   - Track filtered vs total counts

3. Update `display.py`:
   - Add filter summary display (Rich mode)
   - Add filter summary display (Plain mode)

4. Testing:
   - Unit tests for filter validation
   - Unit tests for filter logic
   - Integration test: each filter individually
   - Integration test: combined filters
   - Integration test: conflicting filters (should error)
   - Manual test: verify counts accurate

**Documentation:**
- Update CLAUDE.md with v3.3.1 status
- Update PRD.md to version 3.3.1
- Add v3.3.1 feature descriptions

**Deliverables:**
- ðŸ”„ Installation dates tracked from extensions.json
- ðŸ”„ Last scan dates tracked from cache
- ðŸ”„ JSON/CSV/HTML outputs include date fields
- ðŸ”„ HTML report has 2 new sortable columns (hidden by default)
- ðŸ”„ Cache schema upgraded (v2.0 â†’ v2.1)
- ðŸ”„ 4 new CLI filter flags implemented
- ðŸ”„ Filter validation and conflict detection
- ðŸ”„ Filter summary in output
- ðŸ”„ All tests passing
- ðŸ”„ Documentation updated

---

## Rich/Plain Mode Compatibility Requirements

**Every user-facing display MUST support both modes.**

### Testing Matrix

| Feature | Rich Mode | Plain Mode | Test Status |
|---------|-----------|------------|-------------|
| Extension dir config | Config display | Config display | âœ… Complete |
| Quiet summary | Minimal | Minimal | âœ… Complete |
| Standard summary (NEW) | Panel + Table | Text + Bullets | âœ… Complete |
| Verbose summary | Panel + Tables | Text + Tables | âœ… Complete |
| Failed extensions | Red Table | Text List | âœ… Complete |
| Plain results list (FIX) | N/A | Full list | âœ… Complete |

### Implementation Checklist

For each feature:
- [x] Implement Rich variant with colors/tables/panels
- [x] Implement Plain variant with text/bullets/tables
- [x] Add `if use_rich:` branching
- [x] Test both modes manually
- [x] Add automated tests for both modes

---

## Testing Strategy

### v3.3.0 Testing (Completed)

**Unit Tests:**
- Config file operations (set/get extensions_dir)
- Error categorization logic
- Summary formatting (all 3 modes Ã— 2 formats)
- Failed extensions display (Rich and Plain modes)

**Integration Tests:**
- Full scan with failed extensions
- Config precedence (CLI > config > default)
- Rich/Plain mode compatibility

**Manual Testing:**
```bash
# Test all modes in both Rich and Plain
vscan scan --quiet                    # Minimal
vscan scan --quiet --plain
vscan scan                           # Standard (security-focused)
vscan scan --plain
vscan scan --verbose                 # Full details
vscan scan --verbose --plain

# Test failed extensions (trigger with invalid extensions)
vscan scan --include-ids "fake.extension"

# Test config file
vscan config set scan.extensions_dir ~/custom/path
vscan scan  # Should use config value
vscan scan --extensions-dir /tmp  # Should override
```

---

### v3.3.1 Testing (In Progress)

**Unit Tests:**
- extensions.json parsing (valid, missing, corrupt, missing fields)
- Date format conversion (Unix ms â†’ ISO)
- Cache migration (v2.0 â†’ v2.1)
- Filter validation (conflicting flags should error)
- Filter logic (verified/unverified, with/without vulnerabilities)
- Filter combinations

**Integration Tests:**
- Full scan with installation dates
- Cache storage and retrieval of dates
- JSON output includes both date fields
- CSV output includes 2 new columns
- HTML report displays dates correctly (hidden, sortable)
- Each filter individually
- Combined filters
- Filter counts accurate in output

**Manual Testing:**
```bash
# Test date tracking
vscan scan --output results.json      # Verify installed_at, last_scanned_at
vscan scan --output results.csv       # Verify columns 16 & 17
vscan scan --output report.html       # Verify hidden columns, enable & sort

# Test filters individually
vscan scan --verified-only
vscan scan --unverified-only
vscan scan --with-vulnerabilities
vscan scan --without-vulnerabilities

# Test filter combinations
vscan scan --verified-only --without-vulnerabilities
vscan scan --unverified-only --with-vulnerabilities

# Test conflicting filters (should error)
vscan scan --verified-only --unverified-only
vscan scan --with-vulnerabilities --without-vulnerabilities

# Test with Rich and Plain modes
vscan scan --verified-only --plain
vscan scan --with-vulnerabilities --plain
```

---

## Success Criteria

### Phase 1 (Documentation)
- âœ… v3.3 ROADMAP created with all feature specs
- âœ… STATUS.md reduced to ~200 lines (from ~1400)
- âœ… PRD.md updated to v3.3.0
- âœ… CLAUDE.md updated

### Phase 2 (Foundation)
- âœ… Extension directory configurable in ~/.vscanrc
- âœ… Three output modes working (quiet/standard/verbose)
- âœ… Standard mode hides operational details
- âœ… Both Rich and Plain modes tested

### Phase 3 (UX)
- âœ… Failed extensions tracked and displayed
- âœ… Error categorization accurate and helpful
- âœ… JSON output includes failure details
- âœ… Both Rich and Plain displays working

### Phase 4 (Date Tracking & Filtering) - v3.3.1
- ðŸ”„ Installation dates parsed from extensions.json
- ðŸ”„ Last scan dates tracked from cache
- ðŸ”„ JSON/CSV/HTML outputs include both date fields
- ðŸ”„ HTML report has 2 new sortable columns (hidden by default)
- ðŸ”„ Cache schema upgraded without data loss (v2.0 â†’ v2.1)
- ðŸ”„ 4 CLI filter flags working correctly
- ðŸ”„ Filter validation prevents conflicts
- ðŸ”„ Filter summary displayed in output
- ðŸ”„ All tests passing

---

## Timeline Estimate

| Phase | Duration | Status |
|-------|----------|--------|
| Phase 1: Documentation | 2 hours | âœ… Complete |
| Phase 2: Foundation | 6-8 hours | âœ… Complete |
| Phase 3: UX | 8-12 hours | âœ… Complete |
| **v3.3.0 Total** | **16-22 hours** | **âœ… Complete** |
| Phase 4: Date Tracking & Filtering | 13-19 hours | ðŸ”„ In Progress |
| **v3.3.1 Total** | **13-19 hours** | **ðŸ”„ In Progress** |

**Note:** Feature 4 (Parallel Scanning) was deferred to v3.4.0. See `docs/project/v3.4-ROADMAP.md`.

---

## Open Questions

1. **Failed Extension Retry:**
   - Should we add `--retry-failed-ids` option to retry only failed extensions from previous scan?
   - Would require persisting failed extensions list (add to cache or separate file?)
   - **Decision:** Deferred to future version if user feedback indicates strong need

---

## Documentation Updates

### v3.3.0 Documentation (Completed)
- âœ… Updated CLI help text with new examples
- âœ… Updated `ERROR_HANDLING.md` with failed extensions section
- âœ… Updated `README.md` with v3.3.0 features
- âœ… Updated `CLAUDE.md` with v3.3.0 status

### v3.3.1 Documentation (In Progress)
- ðŸ”„ Update `CLAUDE.md` with v3.3.1 status and features
- ðŸ”„ Update `PRD.md` to version 3.3.1
- ðŸ”„ Add installation date tracking to feature list
- ðŸ”„ Add CLI filtering flags to feature list
- ðŸ”„ Update CLI examples with new flags
- ðŸ”„ Update JSON schema version documentation

**Archiving (Pending):**
- [ ] Create `docs/archive/summaries/v3.3.1-completion-summary.md` (when v3.3.1 complete)
- [ ] Archive v3.3.0 summary to `docs/archive/summaries/v3.3.0-completion-summary.md`

---

**Document Version:** 3.0 (Updated for v3.3.1 planning)
**v3.3.0 Status:** âœ… Implementation Complete
**v3.3.0 Release Date:** 2025-10-25
**v3.3.1 Status:** ðŸ”„ In Progress
**v3.3.1 Target Date:** TBD
