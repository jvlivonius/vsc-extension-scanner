# v4.0 Roadmap: Rich Security Data Integration
**Created:** 2025-11-07
**Status:** Planning Phase
**Target:** Integrate unused vscan.dev API data into application, cache, and exports

---

## Executive Summary

Version 4.0 focuses on **unlocking rich security insights** already available from the vscan.dev API but currently discarded after parsing. This enhancement will persist detailed security analysis data in the cache database and expose it through JSON exports, setting the foundation for enhanced HTML reports and CLI displays in subsequent releases.

### Core Objective

**Make available, persist, and export:**
1. **Security Analysis Modules** (11 modules with individual risk levels)
2. **Score Contributions** (breakdown showing how each module affected score)
3. **Security Notes** (expert commentary from vscan.dev analysts)
4. **Enhanced Metadata** (install counts, ratings, repository links)

### Why v4.0?

This requires a **breaking database schema change**, warranting a major version bump from v3.x (schema v3.0) to v4.x (schema v4.0).

---

## 1. üìä Current State Analysis

### What's Already Parsed But Discarded

**File:** `vscode_scanner/vscan_api.py`

#### A. Security Analysis Modules (PARSED, NOT STORED)

**Location:** `_parse_security_details()` method, lines 613-672
**Code:**
```python
# Already parsed from API response:
module_risk_levels = {
    "metadata": risk_data.get("metadata", {}).get("risk_level", "unknown"),
    "dependencies": risk_data.get("dependencies", {}).get("risk_level", "unknown"),
    "socket": risk_data.get("socket", {}).get("risk_level", "unknown"),
    "virus_total": risk_data.get("virus_total", {}).get("risk_level", "unknown"),
    "permissions": risk_data.get("permissions", {}).get("risk_level", "unknown"),
    "ossf_scorecard": risk_data.get("ossf_scorecard", {}).get("risk_level", "unknown"),
    "network_endpoints": risk_data.get("network_endpoints", {}).get("risk_level", "unknown"),
    "sensitive_info": risk_data.get("sensitive_info", {}).get("risk_level", "unknown"),
    "obfuscation": risk_data.get("obfuscation", {}).get("risk_level", "unknown"),
    "consolidated_ast": risk_data.get("consolidated_ast", {}).get("risk_level", "unknown"),
    "open_grep": risk_data.get("open_grep", {}).get("risk_level", "unknown")
}
# ‚ö†Ô∏è Parsed but NEVER RETURNED or stored
```

**Current Behavior:** Parsed into local variable, then discarded
**Desired Behavior:** Store in cache, export in JSON

#### B. Score Contributions (PARSED, NOT STORED)

**Location:** `_parse_security_details()` method
**Code:**
```python
# Already parsed from API response:
score_contributions = {}
for module_name, module_data in risk_data.items():
    if isinstance(module_data, dict) and "score_contribution" in module_data:
        score_contributions[module_name] = module_data["score_contribution"]
# ‚ö†Ô∏è Parsed but NEVER RETURNED or stored
```

**Example Data:**
```json
{
  "base": 100,
  "metadata": 0,
  "dependencies": -5,
  "socket": -15,
  "permissions": -8,
  "obfuscation": -10
}
```

**Current Behavior:** Parsed into local variable, then discarded
**Desired Behavior:** Store in cache, export in JSON

#### C. Security Notes (PARSED, NOT STORED)

**Location:** `_parse_security_details()` method
**Code:**
```python
# Already parsed from API response:
security_notes = security.get("notes", [])
if isinstance(security_notes, list):
    result["security_notes"] = security_notes
# ‚ö†Ô∏è Assigned to result dict but not in ScanResult dataclass
```

**Example Data:**
```json
[
  "Extension makes network requests to unverified domains",
  "Code contains obfuscation patterns typically used to hide malicious behavior",
  "High permission scope detected: access to all files"
]
```

**Current Behavior:** Parsed but not stored in ScanResult dataclass
**Desired Behavior:** Add to ScanResult, store in cache, export in JSON

#### D. Enhanced Metadata (PARTIALLY STORED)

**Location:** `_parse_extension_metadata()` method, lines 547-611
**Code:**
```python
# Already parsed:
metadata = {
    "repository_url": data.get("repository", {}).get("url"),
    "statistics": {
        "installs": statistics.get("installs"),
        "rating": statistics.get("average_rating"),
        "rating_count": statistics.get("rating_count")
    },
    "keywords": data.get("keywords", []),
    "categories": data.get("categories", []),
    "license": data.get("license"),
    "privacy_policy_url": data.get("privacy_policy_url")
}
```

**Current Behavior:** Some fields stored, others discarded
**Desired Behavior:** Store all fields in cache, export in JSON

---

## 2. üóÑÔ∏è Database Schema Changes

### Current Schema (v3.0)

**File:** `cache_manager.py`, lines ~150-200

```sql
CREATE TABLE IF NOT EXISTS scan_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    extension_id TEXT UNIQUE NOT NULL,
    publisher TEXT,
    version TEXT,
    security_score INTEGER,
    risk_level TEXT,
    vulnerability_count INTEGER,
    last_scanned TEXT,
    scan_date TEXT,
    install_date TEXT,
    verified_publisher INTEGER,
    hmac_signature TEXT NOT NULL
)
```

**Issues:**
- No storage for module_risk_levels (11 fields)
- No storage for score_contributions (dict)
- No storage for security_notes (array)
- No storage for enhanced metadata (installs, ratings, etc.)

### Proposed Schema (v4.0)

#### Option A: JSON Columns (Recommended)

**Advantages:**
- Flexible structure for nested data
- Easy to extend in future
- Simpler migration
- SQLite supports JSON functions (json_extract, etc.)

**Schema:**
```sql
CREATE TABLE IF NOT EXISTS scan_results (
    -- Existing columns (unchanged)
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    extension_id TEXT UNIQUE NOT NULL,
    publisher TEXT,
    version TEXT,
    security_score INTEGER,
    risk_level TEXT,
    vulnerability_count INTEGER,
    last_scanned TEXT,
    scan_date TEXT,
    install_date TEXT,
    verified_publisher INTEGER,

    -- NEW: Rich security data (JSON columns)
    module_risk_levels TEXT,      -- JSON: {"metadata": "low", "socket": "high", ...}
    score_contributions TEXT,      -- JSON: {"base": 100, "socket": -15, ...}
    security_notes TEXT,           -- JSON: ["note1", "note2", ...]

    -- NEW: Enhanced metadata (JSON column)
    enhanced_metadata TEXT,        -- JSON: {"installs": 5000000, "rating": 4.5, ...}

    -- Integrity
    hmac_signature TEXT NOT NULL
)
```

#### Option B: Normalized Tables (Alternative)

**Advantages:**
- Proper relational design
- Better for complex queries on individual modules
- Type safety

**Disadvantages:**
- More complex migration
- More tables to maintain
- Overkill for read-heavy use case

**Schema:**
```sql
-- Main table (existing)
CREATE TABLE scan_results (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    extension_id TEXT UNIQUE NOT NULL,
    -- ... existing columns ...
    hmac_signature TEXT NOT NULL
)

-- NEW: Module risk levels
CREATE TABLE module_risks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    scan_result_id INTEGER NOT NULL,
    module_name TEXT NOT NULL,
    risk_level TEXT NOT NULL,
    score_contribution INTEGER,
    FOREIGN KEY (scan_result_id) REFERENCES scan_results(id) ON DELETE CASCADE
)

-- NEW: Security notes
CREATE TABLE security_notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    scan_result_id INTEGER NOT NULL,
    note TEXT NOT NULL,
    FOREIGN KEY (scan_result_id) REFERENCES scan_results(id) ON DELETE CASCADE
)

-- NEW: Enhanced metadata
CREATE TABLE extension_metadata (
    scan_result_id INTEGER PRIMARY KEY,
    installs INTEGER,
    rating REAL,
    rating_count INTEGER,
    repository_url TEXT,
    license TEXT,
    FOREIGN KEY (scan_result_id) REFERENCES scan_results(id) ON DELETE CASCADE
)
```

### Recommendation: **Option A (JSON Columns)**

**Rationale:**
- Simpler implementation (single table)
- Easier migration path
- Read-heavy workload (no complex queries needed)
- Consistent with current HMAC integrity approach
- Easier to extend in future (just add JSON fields)

---

## 3. üì¶ ScanResult Dataclass Changes

### Current Structure

**File:** `vscode_scanner/types.py`, lines ~50-100

```python
@dataclass
class ScanResult:
    """Represents the security scan result for a single extension."""
    extension_id: str
    publisher: str
    version: str
    security_score: int
    risk_level: str
    vulnerability_count: int
    vulnerabilities: List[Dict[str, Any]]
    dependencies: List[Dict[str, Any]]
    risk_factors: List[str]
    last_scanned: str
    scan_date: Optional[str] = None
    install_date: Optional[str] = None
    verified_publisher: bool = False
```

### Proposed Structure

```python
@dataclass
class ScanResult:
    """Represents the security scan result for a single extension."""
    # Existing fields (unchanged)
    extension_id: str
    publisher: str
    version: str
    security_score: int
    risk_level: str
    vulnerability_count: int
    vulnerabilities: List[Dict[str, Any]]
    dependencies: List[Dict[str, Any]]
    risk_factors: List[str]
    last_scanned: str
    scan_date: Optional[str] = None
    install_date: Optional[str] = None
    verified_publisher: bool = False

    # NEW: Rich security data
    module_risk_levels: Optional[Dict[str, str]] = None  # {"metadata": "low", "socket": "high"}
    score_contributions: Optional[Dict[str, int]] = None  # {"base": 100, "socket": -15}
    security_notes: Optional[List[str]] = None            # ["note1", "note2"]

    # NEW: Enhanced metadata
    installs: Optional[int] = None
    rating: Optional[float] = None
    rating_count: Optional[int] = None
    repository_url: Optional[str] = None
    license: Optional[str] = None
    keywords: Optional[List[str]] = None
    categories: Optional[List[str]] = None
```

**Backward Compatibility:**
- All new fields have default `None` values
- Existing code can create ScanResult without new fields
- No breaking changes to existing tests

---

## 4. üîÑ Data Flow Changes

### Current Flow (Simplified)

```
vscan.dev API Response
    ‚Üì
_parse_security_details() ‚Üí Parses data, discards most
    ‚Üì
ScanResult (limited fields)
    ‚Üì
CacheManager.store() ‚Üí Stores limited data
    ‚Üì
JSON Export ‚Üí Limited fields
```

### Proposed Flow (v4.0)

```
vscan.dev API Response
    ‚Üì
_parse_security_details() ‚Üí Returns module_risk_levels, score_contributions, security_notes
    ‚Üì
_parse_extension_metadata() ‚Üí Returns enhanced metadata
    ‚Üì
ScanResult (ALL fields populated)
    ‚Üì
CacheManager.store() ‚Üí Stores as JSON columns
    ‚Üì
JSON Export ‚Üí Complete data including rich security insights
```

---

## 5. üìù Implementation Plan

### Phase 1: Parser Changes (vscan_api.py)
**Effort:** 2-3 hours
**Files:** `vscode_scanner/vscan_api.py`

**Changes Required:**

#### Step 1.1: Update `_parse_security_details()`

**Current** (lines 613-672):
```python
def _parse_security_details(self, data):
    # ... existing code ...
    module_risk_levels = {...}  # Parsed but not returned
    score_contributions = {...}  # Parsed but not returned
    # ... returns dict without these fields
```

**Proposed:**
```python
def _parse_security_details(self, data):
    # ... existing code ...

    # Parse module risk levels (already done, just need to return)
    module_risk_levels = {
        "metadata": risk_data.get("metadata", {}).get("risk_level", "unknown"),
        "dependencies": risk_data.get("dependencies", {}).get("risk_level", "unknown"),
        "socket": risk_data.get("socket", {}).get("risk_level", "unknown"),
        "virus_total": risk_data.get("virus_total", {}).get("risk_level", "unknown"),
        "permissions": risk_data.get("permissions", {}).get("risk_level", "unknown"),
        "ossf_scorecard": risk_data.get("ossf_scorecard", {}).get("risk_level", "unknown"),
        "network_endpoints": risk_data.get("network_endpoints", {}).get("risk_level", "unknown"),
        "sensitive_info": risk_data.get("sensitive_info", {}).get("risk_level", "unknown"),
        "obfuscation": risk_data.get("obfuscation", {}).get("risk_level", "unknown"),
        "consolidated_ast": risk_data.get("consolidated_ast", {}).get("risk_level", "unknown"),
        "open_grep": risk_data.get("open_grep", {}).get("risk_level", "unknown")
    }

    # Parse score contributions (already done, just need to return)
    score_contributions = {}
    for module_name, module_data in risk_data.items():
        if isinstance(module_data, dict) and "score_contribution" in module_data:
            score_contributions[module_name] = module_data["score_contribution"]

    # Parse security notes (already done, just need to return)
    security_notes = security.get("notes", [])

    return {
        # ... existing fields ...
        "module_risk_levels": module_risk_levels,      # NEW
        "score_contributions": score_contributions,    # NEW
        "security_notes": security_notes if isinstance(security_notes, list) else []  # NEW
    }
```

#### Step 1.2: Update `_parse_extension_metadata()`

**Current** (lines 547-611):
```python
def _parse_extension_metadata(self, data):
    # Some metadata parsed but not all returned
    return {
        "extension_id": ...,
        "publisher": ...,
        # Missing: installs, rating, repository_url, etc.
    }
```

**Proposed:**
```python
def _parse_extension_metadata(self, data):
    statistics = data.get("statistics", {})
    repository = data.get("repository", {})

    return {
        # ... existing fields ...

        # NEW: Enhanced metadata
        "installs": statistics.get("installs"),
        "rating": statistics.get("average_rating"),
        "rating_count": statistics.get("rating_count"),
        "repository_url": repository.get("url"),
        "license": data.get("license"),
        "keywords": data.get("keywords", []),
        "categories": data.get("categories", [])
    }
```

#### Step 1.3: Update `scan_extension()`

**Current** (lines 786-900):
```python
def scan_extension(self, extension_path):
    # ... API calls ...
    metadata = self._parse_extension_metadata(result)
    security = self._parse_security_details(result)

    # Creates ScanResult without new fields
    return ScanResult(
        extension_id=metadata["extension_id"],
        # ... existing fields ...
        # Missing: module_risk_levels, score_contributions, etc.
    )
```

**Proposed:**
```python
def scan_extension(self, extension_path):
    # ... API calls ...
    metadata = self._parse_extension_metadata(result)
    security = self._parse_security_details(result)

    # Creates ScanResult WITH new fields
    return ScanResult(
        # Existing fields
        extension_id=metadata["extension_id"],
        publisher=metadata.get("publisher", "Unknown"),
        version=metadata.get("version", "Unknown"),
        security_score=security["score"],
        risk_level=security["risk_level"],
        vulnerability_count=security["vulnerability_count"],
        vulnerabilities=security["vulnerabilities"],
        dependencies=security["dependencies"],
        risk_factors=security["risk_factors"],
        last_scanned=datetime.now().isoformat(),
        verified_publisher=metadata.get("verified_publisher", False),

        # NEW: Rich security data
        module_risk_levels=security.get("module_risk_levels"),
        score_contributions=security.get("score_contributions"),
        security_notes=security.get("security_notes"),

        # NEW: Enhanced metadata
        installs=metadata.get("installs"),
        rating=metadata.get("rating"),
        rating_count=metadata.get("rating_count"),
        repository_url=metadata.get("repository_url"),
        license=metadata.get("license"),
        keywords=metadata.get("keywords"),
        categories=metadata.get("categories")
    )
```

### Phase 2: ScanResult Dataclass (types.py)
**Effort:** 1 hour
**Files:** `vscode_scanner/types.py`

**Changes:**
- Add new optional fields to ScanResult dataclass (see Section 3)
- All new fields default to `None` for backward compatibility
- Update docstring with new field descriptions

**Testing:**
- Create ScanResult with only old fields ‚Üí Should work (backward compatible)
- Create ScanResult with new fields ‚Üí Should work
- Serialize/deserialize with JSON ‚Üí Should work

### Phase 3: Database Schema Migration (cache_manager.py)
**Effort:** 4-6 hours (including testing)
**Files:** `vscode_scanner/cache_manager.py`

#### Step 3.1: Update Schema Version

**Current:**
```python
CACHE_SCHEMA_VERSION = "3.0"
```

**Proposed:**
```python
CACHE_SCHEMA_VERSION = "4.0"
```

#### Step 3.2: Update Table Schema

**Current** (lines ~150-200):
```python
def _create_tables(self):
    self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS scan_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            extension_id TEXT UNIQUE NOT NULL,
            publisher TEXT,
            version TEXT,
            security_score INTEGER,
            risk_level TEXT,
            vulnerability_count INTEGER,
            last_scanned TEXT,
            scan_date TEXT,
            install_date TEXT,
            verified_publisher INTEGER,
            hmac_signature TEXT NOT NULL
        )
    """)
```

**Proposed:**
```python
def _create_tables(self):
    self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS scan_results (
            -- Existing columns (unchanged)
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            extension_id TEXT UNIQUE NOT NULL,
            publisher TEXT,
            version TEXT,
            security_score INTEGER,
            risk_level TEXT,
            vulnerability_count INTEGER,
            last_scanned TEXT,
            scan_date TEXT,
            install_date TEXT,
            verified_publisher INTEGER,

            -- NEW: Rich security data (JSON columns)
            module_risk_levels TEXT,
            score_contributions TEXT,
            security_notes TEXT,

            -- NEW: Enhanced metadata
            installs INTEGER,
            rating REAL,
            rating_count INTEGER,
            repository_url TEXT,
            license TEXT,
            keywords TEXT,
            categories TEXT,

            -- Integrity
            hmac_signature TEXT NOT NULL
        )
    """)
```

**Note:** JSON fields stored as TEXT, parsed with `json.loads()` when reading

#### Step 3.3: Update `store()` Method

**Current** (lines ~300-400):
```python
def store(self, result: ScanResult):
    # Stores limited fields
    self.cursor.execute("""
        INSERT OR REPLACE INTO scan_results
        (extension_id, publisher, version, security_score, ...)
        VALUES (?, ?, ?, ?, ...)
    """, (
        result.extension_id,
        result.publisher,
        result.version,
        result.security_score,
        # ... existing fields ...
    ))
```

**Proposed:**
```python
def store(self, result: ScanResult):
    import json

    # Serialize JSON fields
    module_risk_levels_json = json.dumps(result.module_risk_levels) if result.module_risk_levels else None
    score_contributions_json = json.dumps(result.score_contributions) if result.score_contributions else None
    security_notes_json = json.dumps(result.security_notes) if result.security_notes else None
    keywords_json = json.dumps(result.keywords) if result.keywords else None
    categories_json = json.dumps(result.categories) if result.categories else None

    self.cursor.execute("""
        INSERT OR REPLACE INTO scan_results
        (extension_id, publisher, version, security_score, risk_level, vulnerability_count,
         last_scanned, scan_date, install_date, verified_publisher,
         module_risk_levels, score_contributions, security_notes,
         installs, rating, rating_count, repository_url, license, keywords, categories,
         hmac_signature)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        # Existing fields
        result.extension_id,
        result.publisher,
        result.version,
        result.security_score,
        result.risk_level,
        result.vulnerability_count,
        result.last_scanned,
        result.scan_date,
        result.install_date,
        1 if result.verified_publisher else 0,

        # NEW: Rich security data
        module_risk_levels_json,
        score_contributions_json,
        security_notes_json,

        # NEW: Enhanced metadata
        result.installs,
        result.rating,
        result.rating_count,
        result.repository_url,
        result.license,
        keywords_json,
        categories_json,

        # HMAC signature
        self._generate_hmac(result.extension_id, result.version, result.security_score)
    ))
```

#### Step 3.4: Update `get()` Method

**Current** (lines ~450-550):
```python
def get(self, extension_id: str) -> Optional[ScanResult]:
    # Reads limited fields
    row = self.cursor.execute(
        "SELECT extension_id, publisher, version, ... FROM scan_results WHERE extension_id = ?",
        (extension_id,)
    ).fetchone()

    if row:
        return ScanResult(
            extension_id=row[0],
            publisher=row[1],
            # ... existing fields ...
        )
```

**Proposed:**
```python
def get(self, extension_id: str) -> Optional[ScanResult]:
    import json

    row = self.cursor.execute("""
        SELECT extension_id, publisher, version, security_score, risk_level, vulnerability_count,
               last_scanned, scan_date, install_date, verified_publisher,
               module_risk_levels, score_contributions, security_notes,
               installs, rating, rating_count, repository_url, license, keywords, categories
        FROM scan_results WHERE extension_id = ?
    """, (extension_id,)).fetchone()

    if row:
        # Deserialize JSON fields
        module_risk_levels = json.loads(row[10]) if row[10] else None
        score_contributions = json.loads(row[11]) if row[11] else None
        security_notes = json.loads(row[12]) if row[12] else None
        keywords = json.loads(row[18]) if row[18] else None
        categories = json.loads(row[19]) if row[19] else None

        return ScanResult(
            # Existing fields
            extension_id=row[0],
            publisher=row[1],
            version=row[2],
            security_score=row[3],
            risk_level=row[4],
            vulnerability_count=row[5],
            vulnerabilities=[],  # Not stored in cache
            dependencies=[],     # Not stored in cache
            risk_factors=[],     # Not stored in cache
            last_scanned=row[6],
            scan_date=row[7],
            install_date=row[8],
            verified_publisher=bool(row[9]),

            # NEW: Rich security data
            module_risk_levels=module_risk_levels,
            score_contributions=score_contributions,
            security_notes=security_notes,

            # NEW: Enhanced metadata
            installs=row[13],
            rating=row[14],
            rating_count=row[15],
            repository_url=row[16],
            license=row[17],
            keywords=keywords,
            categories=categories
        )
```

#### Step 3.5: Migration Strategy

**Option A: Auto-Regenerate (Recommended for v3.x ‚Üí v4.0)**

Following established pattern from v3.7.0 Phase 1.1:

```python
def _check_schema_version(self):
    """Check if schema needs regeneration."""
    current_version = self._get_schema_version()

    if current_version != CACHE_SCHEMA_VERSION:
        logger.warning(
            f"Cache schema version mismatch (found {current_version}, expected {CACHE_SCHEMA_VERSION}). "
            f"Regenerating cache database..."
        )
        self._regenerate_database()
```

**Benefits:**
- Simple implementation (no migration code)
- Consistent with recent v3.7.0 approach
- Users re-scan extensions (leverages API caching)
- Clean slate for new schema

**Drawbacks:**
- Loses historical scan data
- Requires re-scanning all extensions

**Option B: Migrate Existing Data**

```python
def _migrate_v3_to_v4(self):
    """Migrate v3.0 schema to v4.0."""
    # Add new columns with ALTER TABLE
    self.cursor.execute("ALTER TABLE scan_results ADD COLUMN module_risk_levels TEXT")
    self.cursor.execute("ALTER TABLE scan_results ADD COLUMN score_contributions TEXT")
    self.cursor.execute("ALTER TABLE scan_results ADD COLUMN security_notes TEXT")
    self.cursor.execute("ALTER TABLE scan_results ADD COLUMN installs INTEGER")
    self.cursor.execute("ALTER TABLE scan_results ADD COLUMN rating REAL")
    # ... etc

    # Update schema version
    self.cursor.execute("UPDATE schema_info SET version = ?", (CACHE_SCHEMA_VERSION,))
    self.conn.commit()
```

**Benefits:**
- Preserves existing cache entries
- No re-scanning needed for old data
- Graceful upgrade

**Drawbacks:**
- Old entries have NULL for new fields (expected, acceptable)
- More complex implementation
- Still needs re-scan to populate new fields

**Recommendation:** **Option A (Auto-Regenerate)**
- Simpler, cleaner
- Consistent with v3.7 precedent
- New fields require API data anyway (migration can't populate them)

### Phase 4: JSON Export Updates (output_formatter.py)
**Effort:** 2-3 hours
**Files:** `vscode_scanner/output_formatter.py`

#### Step 4.1: Update `to_json()` Method

**Current** (lines ~50-150):
```python
def to_json(results: List[ScanResult]) -> str:
    json_results = []
    for result in results:
        json_results.append({
            "extension_id": result.extension_id,
            "publisher": result.publisher,
            "version": result.version,
            "security_score": result.security_score,
            # ... existing fields ...
        })
    return json.dumps({"results": json_results}, indent=2)
```

**Proposed:**
```python
def to_json(results: List[ScanResult]) -> str:
    json_results = []
    for result in results:
        result_dict = {
            # Existing fields
            "extension_id": result.extension_id,
            "publisher": result.publisher,
            "version": result.version,
            "security_score": result.security_score,
            "risk_level": result.risk_level,
            "vulnerability_count": result.vulnerability_count,
            "vulnerabilities": result.vulnerabilities,
            "dependencies": result.dependencies,
            "risk_factors": result.risk_factors,
            "last_scanned": result.last_scanned,
            "scan_date": result.scan_date,
            "install_date": result.install_date,
            "verified_publisher": result.verified_publisher,
        }

        # NEW: Rich security data (only include if present)
        if result.module_risk_levels:
            result_dict["module_risk_levels"] = result.module_risk_levels
        if result.score_contributions:
            result_dict["score_contributions"] = result.score_contributions
        if result.security_notes:
            result_dict["security_notes"] = result.security_notes

        # NEW: Enhanced metadata (only include if present)
        if result.installs is not None:
            result_dict["installs"] = result.installs
        if result.rating is not None:
            result_dict["rating"] = result.rating
        if result.rating_count is not None:
            result_dict["rating_count"] = result.rating_count
        if result.repository_url:
            result_dict["repository_url"] = result.repository_url
        if result.license:
            result_dict["license"] = result.license
        if result.keywords:
            result_dict["keywords"] = result.keywords
        if result.categories:
            result_dict["categories"] = result.categories

        json_results.append(result_dict)

    return json.dumps({"results": json_results}, indent=2)
```

#### Step 4.2: Example Enhanced JSON Output

**Before** (v3.x):
```json
{
  "results": [
    {
      "extension_id": "ms-python.python",
      "publisher": "Microsoft",
      "version": "2023.10.1",
      "security_score": 82,
      "risk_level": "medium",
      "vulnerability_count": 0,
      "verified_publisher": true
    }
  ]
}
```

**After** (v4.0):
```json
{
  "results": [
    {
      "extension_id": "ms-python.python",
      "publisher": "Microsoft",
      "version": "2023.10.1",
      "security_score": 82,
      "risk_level": "medium",
      "vulnerability_count": 0,
      "verified_publisher": true,

      "module_risk_levels": {
        "metadata": "low",
        "dependencies": "low",
        "socket": "high",
        "virus_total": "low",
        "permissions": "high",
        "ossf_scorecard": "medium",
        "network_endpoints": "medium",
        "sensitive_info": "low",
        "obfuscation": "none",
        "consolidated_ast": "low",
        "open_grep": "low"
      },

      "score_contributions": {
        "base": 100,
        "metadata": 0,
        "dependencies": -2,
        "socket": -10,
        "permissions": -8,
        "network_endpoints": -5,
        "obfuscation": 0
      },

      "security_notes": [
        "Extension requests broad file system permissions",
        "Makes network calls to 3rd party analytics services",
        "All dependencies are up-to-date with no known CVEs"
      ],

      "installs": 50000000,
      "rating": 4.8,
      "rating_count": 12345,
      "repository_url": "https://github.com/microsoft/vscode-python",
      "license": "MIT",
      "keywords": ["python", "linting", "debugging"],
      "categories": ["Programming Languages"]
    }
  ]
}
```

### Phase 5: Testing
**Effort:** 4-6 hours
**Files:** New test files + updates to existing

#### Test Cases Required:

**5.1 Parser Tests** (`tests/test_vscan_api.py`)
- Test `_parse_security_details()` returns module_risk_levels
- Test `_parse_security_details()` returns score_contributions
- Test `_parse_security_details()` returns security_notes
- Test `_parse_extension_metadata()` returns enhanced metadata
- Test `scan_extension()` creates ScanResult with all new fields

**5.2 ScanResult Tests** (`tests/test_types.py`)
- Test ScanResult creation with new fields
- Test ScanResult creation without new fields (backward compatibility)
- Test ScanResult serialization/deserialization

**5.3 Cache Tests** (`tests/test_cache_manager.py`)
- Test store() with new fields persists to database
- Test get() retrieves new fields correctly
- Test JSON serialization/deserialization of dict fields
- Test NULL handling for missing fields
- Test HMAC integrity with new schema
- Test schema version bump (v3.0 ‚Üí v4.0)
- Test auto-regeneration when schema version mismatch

**5.4 JSON Export Tests** (`tests/test_output_formatter.py`)
- Test JSON export includes new fields
- Test JSON structure matches specification
- Test optional field handling (present vs. absent)
- Test backward compatibility (old ScanResult still works)

**5.5 Integration Tests** (`tests/test_integration.py`)
- Test full flow: API ‚Üí Parser ‚Üí ScanResult ‚Üí Cache ‚Üí JSON export
- Test cached results include new fields
- Test fresh scan vs. cached scan (both include new data)

**Coverage Target:** Maintain 85%+ overall, 95%+ for new code

---

## 6. üó∫Ô∏è Implementation Checklist

### Pre-Implementation
- [ ] Create feature branch: `feature/v4.0-rich-security-data`
- [ ] Review this roadmap document
- [ ] Set up test environment for schema changes

### Phase 1: Parser Changes
- [ ] Update `_parse_security_details()` to return module_risk_levels
- [ ] Update `_parse_security_details()` to return score_contributions
- [ ] Update `_parse_security_details()` to return security_notes
- [ ] Update `_parse_extension_metadata()` to return enhanced metadata
- [ ] Update `scan_extension()` to populate new ScanResult fields
- [ ] Add parser unit tests
- [ ] Verify all tests pass

### Phase 2: ScanResult Dataclass
- [ ] Add new optional fields to ScanResult
- [ ] Update ScanResult docstring
- [ ] Add ScanResult unit tests
- [ ] Verify backward compatibility

### Phase 3: Database Schema
- [ ] Bump schema version to 4.0
- [ ] Update `_create_tables()` with new columns
- [ ] Update `store()` method with JSON serialization
- [ ] Update `get()` method with JSON deserialization
- [ ] Update `get_all()` method similarly
- [ ] Implement auto-regeneration for v3.0 ‚Üí v4.0
- [ ] Add cache manager tests
- [ ] Test HMAC integrity with new schema
- [ ] Verify migration/regeneration works

### Phase 4: JSON Export
- [ ] Update `to_json()` method
- [ ] Add conditional inclusion of new fields
- [ ] Add JSON export tests
- [ ] Verify output structure

### Phase 5: Testing & Validation
- [ ] Run full test suite
- [ ] Verify 85%+ coverage maintained
- [ ] Manual testing: fresh scan with new data
- [ ] Manual testing: cache regeneration
- [ ] Manual testing: JSON export structure
- [ ] Security audit: HMAC still working correctly

### Phase 6: Documentation
- [ ] Update CHANGELOG.md with breaking changes
- [ ] Update docs/guides/API_REFERENCE.md
- [ ] Update README.md with new JSON structure
- [ ] Document schema version bump in STATUS.md
- [ ] Add migration notes for users

### Phase 7: Release
- [ ] Create pull request
- [ ] Code review
- [ ] Merge to main
- [ ] Tag release: v4.0.0
- [ ] Build and publish to PyPI

---

## 7. ‚ö†Ô∏è Breaking Changes & Migration

### What Breaks in v4.0

**1. Cache Database Schema**
- Schema version: v3.0 ‚Üí v4.0
- Database file will be regenerated
- Users will need to re-scan extensions

**2. JSON Export Structure**
- New fields added to JSON output
- **Backward compatible:** Old parsers ignore new fields
- **Forward compatible:** New fields optional

**3. ScanResult Dataclass**
- New optional fields added
- **Backward compatible:** Existing code works (defaults to None)

### Migration Guide for Users

**What Users Will Experience:**

```bash
$ vscan scan

Warning: Cache schema version mismatch (found 3.0, expected 4.0).
Regenerating cache database...

‚úì Cache database regenerated
Scanning 47 extensions...
[Progress bar]
```

**User Action Required:** None (automatic regeneration)

**Data Loss:** Historical scan dates preserved in cache will be lost, but this is acceptable as fresh scans provide richer data

### Migration Guide for Developers

**If consuming JSON exports:**

```python
# Old code (still works)
score = result["security_score"]
risk = result["risk_level"]

# New code (access rich data)
if "module_risk_levels" in result:
    socket_risk = result["module_risk_levels"]["socket"]

if "score_contributions" in result:
    socket_impact = result["score_contributions"]["socket"]

if "security_notes" in result:
    for note in result["security_notes"]:
        print(f"‚ö†Ô∏è {note}")
```

**Recommendation:** Check for field presence before accessing

---

## 8. üéØ Success Criteria

### Must Have (v4.0 Release Blockers)
- ‚úÖ All 11 security analysis modules stored in cache
- ‚úÖ Score contributions stored in cache
- ‚úÖ Security notes stored in cache
- ‚úÖ Enhanced metadata stored in cache
- ‚úÖ JSON exports include all new fields
- ‚úÖ Database schema v4.0 implemented
- ‚úÖ Auto-regeneration working for v3.0 ‚Üí v4.0
- ‚úÖ All tests passing (1,035+ tests)
- ‚úÖ Test coverage ‚â•85% maintained
- ‚úÖ HMAC integrity preserved
- ‚úÖ 0 architecture violations
- ‚úÖ 0 security vulnerabilities

### Should Have (High Priority)
- ‚úÖ Backward compatibility for ScanResult
- ‚úÖ Graceful handling of missing fields
- ‚úÖ Clear migration messaging for users
- ‚úÖ Documentation updated

### Nice to Have (Low Priority)
- CSV export updated with new fields (defer to v4.1)
- CLI display of new fields (defer to v4.1)
- HTML report updates (defer to v4.1)

---

## 9. üöÄ Post-v4.0 Roadmap

Once rich security data is available in cache and JSON exports, subsequent releases can leverage it:

### v4.1: CLI Display Enhancements
- Add `--detailed` flag to show module-by-module risk
- Display security notes in terminal output
- Show score breakdown in verbose mode

### v4.2: HTML Report Enhancements
- Add security notes section
- Add score contributions chart (Chart.js)
- Add module risk breakdown table
- Display enhanced metadata (installs, ratings, links)

### v4.3: CSV Export Updates
- Add new fields to CSV format
- Flatten nested structures for spreadsheet compatibility

---

## 10. üìö References

**Related Documents:**
- [v3.8-enhancement-opportunities.md](v3.8-enhancement-opportunities.md) - Overall enhancement analysis
- [docs/guides/ARCHITECTURE.md](../guides/ARCHITECTURE.md) - Architecture principles
- [docs/guides/SECURITY.md](../guides/SECURITY.md) - Security requirements
- [docs/guides/TESTING.md](../guides/TESTING.md) - Testing guidelines

**Code References:**
- `vscode_scanner/vscan_api.py` (lines 547-900) - API parsing logic
- `vscode_scanner/cache_manager.py` (lines 150-550) - Database operations
- `vscode_scanner/types.py` (lines 50-100) - ScanResult dataclass
- `vscode_scanner/output_formatter.py` (lines 50-150) - JSON export

**Previous Schema Changes:**
- v3.7.0 Phase 1.1 - Cache schema simplification (auto-regenerate pattern)
- Precedent for v4.0 migration strategy

---

## Conclusion

Version 4.0 unlocks the **rich security insights** already provided by vscan.dev API but currently discarded. This foundation enables future enhancements (CLI displays, HTML reports, advanced filtering) while maintaining the project's high quality and security standards.

**Estimated Total Effort:** 2-3 days
**Risk Level:** LOW-MEDIUM (breaking schema change, but auto-regeneration mitigates)
**User Value:** HIGH (foundation for all future rich data features)
**Ready for Implementation:** ‚úÖ YES
